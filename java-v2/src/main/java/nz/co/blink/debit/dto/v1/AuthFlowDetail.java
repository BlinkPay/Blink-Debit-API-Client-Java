/*
 * Blink Debit (PayNow and AutoPay) Payments API
 * APIs to execute Direct Credit payments for customers who use online banking with supported banks.  These APIs power **Blink PayNow** enabling one-off payments, and **Blink AutoPay** enabling recurring payments.  **Request IDs** Request IDs are included in the header in every response, to assist in tracing and debugging.  **API Change Policy** Additive changes may be made to request query parameters and JSON responses. To preserve backward compatibility, endpoint naming updates or JSON elements that already exist will not be removed or renamed until a major version (URL) change. This policy applies only after the official v1 release.
 *
 * The version of the OpenAPI document: 1.0.30
 * Contact: sysadmin@blinkpay.co.nz
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package nz.co.blink.debit.dto.v1;

import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import java.util.Locale;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.net.URI;
import java.util.Arrays;
import nz.co.blink.debit.dto.v1.Bank;
import nz.co.blink.debit.dto.v1.DecoupledFlow;
import nz.co.blink.debit.dto.v1.GatewayFlow;
import nz.co.blink.debit.dto.v1.GatewayFlowAllOfFlowHint;
import nz.co.blink.debit.dto.v1.IdentifierType;
import nz.co.blink.debit.dto.v1.RedirectFlow;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import javax.validation.constraints.*;
import javax.validation.Valid;

import com.fasterxml.jackson.core.type.TypeReference;

import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Locale;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.MapperFeature;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;
import nz.co.blink.debit.dto.JSON;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.17.0")
@JsonDeserialize(using = AuthFlowDetail.AuthFlowDetailDeserializer.class)
@JsonSerialize(using = AuthFlowDetail.AuthFlowDetailSerializer.class)
public class AuthFlowDetail extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(AuthFlowDetail.class.getName());

    public enum TypeEnum {
        GATEWAY("gateway"), REDIRECT("redirect"), DECOUPLED("decoupled");
        private String value;
        TypeEnum(String value) { this.value = value; }
        @Override
        @JsonValue
        public String toString() { return String.valueOf(value); }
        @JsonCreator
        public static TypeEnum fromValue(String type) {
            for (TypeEnum t : TypeEnum.values()) if (String.valueOf(t.value).equals(type)) return t;
            throw new IllegalArgumentException("Unknown type: " + type);
        }
    }
    private TypeEnum type;
    public AuthFlowDetail type(TypeEnum type) { this.type = type; return this; }
    public TypeEnum getType() { return type; }
    public void setType(TypeEnum type) { this.type = type; }
    private static final Logger log
    public static class AuthFlowDetailSerializer extends StdSerializer<AuthFlowDetail> {
        public AuthFlowDetailSerializer(Class<AuthFlowDetail> t) {
            super(t);
        }

        public AuthFlowDetailSerializer() {
            this(null);
        }

        @Override
        public void serialize(AuthFlowDetail value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {
            jgen.writeObject(value.getActualInstance());
        }
    }

    public static class AuthFlowDetailDeserializer extends StdDeserializer<AuthFlowDetail> {
        public AuthFlowDetailDeserializer() {
            this(AuthFlowDetail.class);
        }

        public AuthFlowDetailDeserializer(Class<?> vc) {
            super(vc);
        }

        @Override
        public AuthFlowDetail deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {
            JsonNode tree = jp.readValueAsTree();
            Object deserialized = null;
            boolean typeCoercion = ctxt.isEnabled(MapperFeature.ALLOW_COERCION_OF_SCALARS);
            int match = 0;
            JsonToken token = tree.traverse(jp.getCodec()).nextToken();
            // deserialize DecoupledFlow
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (DecoupledFlow.class.equals(Integer.class) || DecoupledFlow.class.equals(Long.class) || DecoupledFlow.class.equals(Float.class) || DecoupledFlow.class.equals(Double.class) || DecoupledFlow.class.equals(Boolean.class) || DecoupledFlow.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((DecoupledFlow.class.equals(Integer.class) || DecoupledFlow.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((DecoupledFlow.class.equals(Float.class) || DecoupledFlow.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (DecoupledFlow.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (DecoupledFlow.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(DecoupledFlow.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'DecoupledFlow'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'DecoupledFlow'", e);
            }

            // deserialize GatewayFlow
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (GatewayFlow.class.equals(Integer.class) || GatewayFlow.class.equals(Long.class) || GatewayFlow.class.equals(Float.class) || GatewayFlow.class.equals(Double.class) || GatewayFlow.class.equals(Boolean.class) || GatewayFlow.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((GatewayFlow.class.equals(Integer.class) || GatewayFlow.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((GatewayFlow.class.equals(Float.class) || GatewayFlow.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (GatewayFlow.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (GatewayFlow.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(GatewayFlow.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'GatewayFlow'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'GatewayFlow'", e);
            }

            // deserialize RedirectFlow
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (RedirectFlow.class.equals(Integer.class) || RedirectFlow.class.equals(Long.class) || RedirectFlow.class.equals(Float.class) || RedirectFlow.class.equals(Double.class) || RedirectFlow.class.equals(Boolean.class) || RedirectFlow.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((RedirectFlow.class.equals(Integer.class) || RedirectFlow.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((RedirectFlow.class.equals(Float.class) || RedirectFlow.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (RedirectFlow.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (RedirectFlow.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(RedirectFlow.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'RedirectFlow'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'RedirectFlow'", e);
            }

            if (match == 1) {
                AuthFlowDetail ret = new AuthFlowDetail();
                ret.setActualInstance(deserialized);
                return ret;
            }
            throw new IOException(String.format(Locale.ROOT, "Failed deserialization for AuthFlowDetail: %d classes match result, expected 1", match));
        }

        /**
         * Handle deserialization of the 'null' value.
         */
        @Override
        public AuthFlowDetail getNullValue(DeserializationContext ctxt) throws JsonMappingException {
            throw new JsonMappingException(ctxt.getParser(), "AuthFlowDetail cannot be null");
        }
    }

    // store a list of schema names defined in oneOf
    public static final Map<String, Class<?>> schemas = new HashMap<>();

    public AuthFlowDetail() {
        super("oneOf", Boolean.FALSE);
    }
  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   * @param key the name of the property
   * @param value the value of the property
   * @return self reference
   */
  @JsonAnySetter
  public AuthFlowDetail putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) properties.
   * @return the additional (undeclared) properties
   */
  @JsonAnyGetter
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   * @param key the name of the property
   * @return the additional (undeclared) property with the specified name
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }

    /**
     * Return true if this auth_flow_detail object is equal to o.
     */
    @Override
    public boolean equals(Object o) {
        return super.equals(o) && Objects.equals(this.additionalProperties, ((AuthFlowDetail)o).additionalProperties);
    }

    @Override
    public int hashCode() {
        return Objects.hash(getActualInstance(), isNullable(), getSchemaType(), additionalProperties);
    }
    public AuthFlowDetail(DecoupledFlow o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public AuthFlowDetail(GatewayFlow o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public AuthFlowDetail(RedirectFlow o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("DecoupledFlow", DecoupledFlow.class);
        schemas.put("GatewayFlow", GatewayFlow.class);
        schemas.put("RedirectFlow", RedirectFlow.class);
        JSON.registerDescendants(AuthFlowDetail.class, Collections.unmodifiableMap(schemas));
        // Initialize and register the discriminator mappings.
        Map<String, Class<?>> mappings = new HashMap<String, Class<?>>();
        mappings.put("decoupled", DecoupledFlow.class);
        mappings.put("gateway", GatewayFlow.class);
        mappings.put("redirect", RedirectFlow.class);
        mappings.put("auth_flow_detail", AuthFlowDetail.class);
        JSON.registerDiscriminator(AuthFlowDetail.class, "type", mappings);
    }

    @Override
    public Map<String, Class<?>> getSchemas() {
        return AuthFlowDetail.schemas;
    }

    /**
     * Set the instance that matches the oneOf child schema, check
     * the instance parameter is valid against the oneOf child schemas:
     * DecoupledFlow, GatewayFlow, RedirectFlow
     *
     * It could be an instance of the 'oneOf' schemas.
     * The oneOf child schemas may themselves be a composed schema (allOf, anyOf, oneOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (JSON.isInstanceOf(DecoupledFlow.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(GatewayFlow.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(RedirectFlow.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be DecoupledFlow, GatewayFlow, RedirectFlow");
    }

    /**
     * Get the actual instance, which can be the following:
     * DecoupledFlow, GatewayFlow, RedirectFlow
     *
     * @return The actual instance (DecoupledFlow, GatewayFlow, RedirectFlow)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of `DecoupledFlow`. If the actual instance is not `DecoupledFlow`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `DecoupledFlow`
     * @throws ClassCastException if the instance is not `DecoupledFlow`
     */
    public DecoupledFlow getDecoupledFlow() throws ClassCastException {
        return (DecoupledFlow)super.getActualInstance();
    }

    /**
     * Get the actual instance of `GatewayFlow`. If the actual instance is not `GatewayFlow`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `GatewayFlow`
     * @throws ClassCastException if the instance is not `GatewayFlow`
     */
    public GatewayFlow getGatewayFlow() throws ClassCastException {
        return (GatewayFlow)super.getActualInstance();
    }

    /**
     * Get the actual instance of `RedirectFlow`. If the actual instance is not `RedirectFlow`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `RedirectFlow`
     * @throws ClassCastException if the instance is not `RedirectFlow`
     */
    public RedirectFlow getRedirectFlow() throws ClassCastException {
        return (RedirectFlow)super.getActualInstance();
    }



  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    if (getActualInstance() instanceof GatewayFlow) {
        if (getActualInstance() != null) {
          joiner.add(((GatewayFlow)getActualInstance()).toUrlQueryString(prefix + "one_of_0" + suffix));
        }
        return joiner.toString();
    }
    if (getActualInstance() instanceof RedirectFlow) {
        if (getActualInstance() != null) {
          joiner.add(((RedirectFlow)getActualInstance()).toUrlQueryString(prefix + "one_of_1" + suffix));
        }
        return joiner.toString();
    }
    if (getActualInstance() instanceof DecoupledFlow) {
        if (getActualInstance() != null) {
          joiner.add(((DecoupledFlow)getActualInstance()).toUrlQueryString(prefix + "one_of_2" + suffix));
        }
        return joiner.toString();
    }
    return null;
  }

}

