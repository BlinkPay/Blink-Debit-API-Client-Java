/*
 * Blink Debit (PayNow and AutoPay) Payments API
 * APIs to execute Direct Credit payments for customers who use online banking with supported banks.  These APIs power **Blink PayNow** enabling one-off payments, and **Blink AutoPay** enabling recurring payments.  **Request IDs** Request IDs are included in the header in every response, to assist in tracing and debugging.  **API Change Policy** Additive changes may be made to request query parameters and JSON responses. To preserve backward compatibility, endpoint naming updates or JSON elements that already exist will not be removed or renamed until a major version (URL) change. This policy applies only after the official v1 release.
 *
 * The version of the OpenAPI document: 1.0.30
 * Contact: sysadmin@blinkpay.co.nz
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package nz.co.blink.debit.dto.v1;

import nz.co.blink.debit.dto.AbstractOpenApiSchema;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import java.util.Locale;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.time.OffsetDateTime;
import java.util.Arrays;
import nz.co.blink.debit.dto.v1.Amount;
import nz.co.blink.debit.dto.v1.AuthFlow;
import nz.co.blink.debit.dto.v1.EnduringConsentRequest;
import nz.co.blink.debit.dto.v1.Pcr;
import nz.co.blink.debit.dto.v1.Period;
import nz.co.blink.debit.dto.v1.SingleConsentRequest;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import javax.validation.constraints.*;
import javax.validation.Valid;

import com.fasterxml.jackson.core.type.TypeReference;

import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Locale;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.MapperFeature;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;
import nz.co.blink.debit.dto.JSON;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.17.0")
@JsonDeserialize(using = ConsentDetail.ConsentDetailDeserializer.class)
@JsonSerialize(using = ConsentDetail.ConsentDetailSerializer.class)
public class ConsentDetail extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(ConsentDetail.class.getName());

    public enum TypeEnum {
        SINGLE("single"), ENDURING("enduring");
        private String value;
        TypeEnum(String value) { this.value = value; }
        @Override
        @JsonValue
        public String toString() { return String.valueOf(value); }
        @JsonCreator
        public static TypeEnum fromValue(String type) {
            for (TypeEnum t : TypeEnum.values()) if (String.valueOf(t.value).equals(type)) return t;
            throw new IllegalArgumentException("Unknown type: " + type);
        }
    }
    private TypeEnum type;
    public ConsentDetail type(TypeEnum type) { this.type = type; return this; }
    public TypeEnum getType() { return type; }
    public void setType(TypeEnum type) { this.type = type; }

    public static class ConsentDetailSerializer extends StdSerializer<ConsentDetail> {
        public ConsentDetailSerializer(Class<ConsentDetail> t) {
            super(t);
        }

        public ConsentDetailSerializer() {
            this(null);
        }

        @Override
        public void serialize(ConsentDetail value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {
            jgen.writeObject(value.getActualInstance());
        }
    }

    public static class ConsentDetailDeserializer extends StdDeserializer<ConsentDetail> {
        public ConsentDetailDeserializer() {
            this(ConsentDetail.class);
        }

        public ConsentDetailDeserializer(Class<?> vc) {
            super(vc);
        }

        @Override
        public ConsentDetail deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {
            JsonNode tree = jp.readValueAsTree();
            Object deserialized = null;
            boolean typeCoercion = ctxt.isEnabled(MapperFeature.ALLOW_COERCION_OF_SCALARS);
            int match = 0;
            JsonToken token = tree.traverse(jp.getCodec()).nextToken();
            // deserialize EnduringConsentRequest
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (EnduringConsentRequest.class.equals(Integer.class) || EnduringConsentRequest.class.equals(Long.class) || EnduringConsentRequest.class.equals(Float.class) || EnduringConsentRequest.class.equals(Double.class) || EnduringConsentRequest.class.equals(Boolean.class) || EnduringConsentRequest.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((EnduringConsentRequest.class.equals(Integer.class) || EnduringConsentRequest.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((EnduringConsentRequest.class.equals(Float.class) || EnduringConsentRequest.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (EnduringConsentRequest.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (EnduringConsentRequest.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(EnduringConsentRequest.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'EnduringConsentRequest'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'EnduringConsentRequest'", e);
            }

            // deserialize SingleConsentRequest
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (SingleConsentRequest.class.equals(Integer.class) || SingleConsentRequest.class.equals(Long.class) || SingleConsentRequest.class.equals(Float.class) || SingleConsentRequest.class.equals(Double.class) || SingleConsentRequest.class.equals(Boolean.class) || SingleConsentRequest.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((SingleConsentRequest.class.equals(Integer.class) || SingleConsentRequest.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((SingleConsentRequest.class.equals(Float.class) || SingleConsentRequest.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (SingleConsentRequest.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (SingleConsentRequest.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(SingleConsentRequest.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'SingleConsentRequest'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'SingleConsentRequest'", e);
            }

            if (match == 1) {
                ConsentDetail ret = new ConsentDetail();
                ret.setActualInstance(deserialized);
                return ret;
            }
            throw new IOException(String.format(Locale.ROOT, "Failed deserialization for ConsentDetail: %d classes match result, expected 1", match));
        }

        /**
         * Handle deserialization of the 'null' value.
         */
        @Override
        public ConsentDetail getNullValue(DeserializationContext ctxt) throws JsonMappingException {
            throw new JsonMappingException(ctxt.getParser(), "ConsentDetail cannot be null");
        }
    }

    // store a list of schema names defined in oneOf
    public static final Map<String, Class<?>> schemas = new HashMap<>();

    public ConsentDetail() {
        super("oneOf", Boolean.FALSE);
    }
  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   * @param key the name of the property
   * @param value the value of the property
   * @return self reference
   */
  @JsonAnySetter
  public ConsentDetail putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) properties.
   * @return the additional (undeclared) properties
   */
  @JsonAnyGetter
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   * @param key the name of the property
   * @return the additional (undeclared) property with the specified name
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }

    /**
     * Return true if this consent_detail object is equal to o.
     */
    @Override
    public boolean equals(Object o) {
        return super.equals(o) && Objects.equals(this.additionalProperties, ((ConsentDetail)o).additionalProperties);
    }

    @Override
    public int hashCode() {
        return Objects.hash(getActualInstance(), isNullable(), getSchemaType(), additionalProperties);
    }
    public ConsentDetail(EnduringConsentRequest o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public ConsentDetail(SingleConsentRequest o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("EnduringConsentRequest", EnduringConsentRequest.class);
        schemas.put("SingleConsentRequest", SingleConsentRequest.class);
        JSON.registerDescendants(ConsentDetail.class, Collections.unmodifiableMap(schemas));
        // Initialize and register the discriminator mappings.
        Map<String, Class<?>> mappings = new HashMap<String, Class<?>>();
        mappings.put("enduring", EnduringConsentRequest.class);
        mappings.put("single", SingleConsentRequest.class);
        mappings.put("consent_detail", ConsentDetail.class);
        JSON.registerDiscriminator(ConsentDetail.class, "type", mappings);
    }

    @Override
    public Map<String, Class<?>> getSchemas() {
        return ConsentDetail.schemas;
    }

    /**
     * Set the instance that matches the oneOf child schema, check
     * the instance parameter is valid against the oneOf child schemas:
     * EnduringConsentRequest, SingleConsentRequest
     *
     * It could be an instance of the 'oneOf' schemas.
     * The oneOf child schemas may themselves be a composed schema (allOf, anyOf, oneOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (JSON.isInstanceOf(EnduringConsentRequest.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(SingleConsentRequest.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be EnduringConsentRequest, SingleConsentRequest");
    }

    /**
     * Get the actual instance, which can be the following:
     * EnduringConsentRequest, SingleConsentRequest
     *
     * @return The actual instance (EnduringConsentRequest, SingleConsentRequest)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of `EnduringConsentRequest`. If the actual instance is not `EnduringConsentRequest`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EnduringConsentRequest`
     * @throws ClassCastException if the instance is not `EnduringConsentRequest`
     */
    public EnduringConsentRequest getEnduringConsentRequest() throws ClassCastException {
        return (EnduringConsentRequest)super.getActualInstance();
    }

    /**
     * Get the actual instance of `SingleConsentRequest`. If the actual instance is not `SingleConsentRequest`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `SingleConsentRequest`
     * @throws ClassCastException if the instance is not `SingleConsentRequest`
     */
    public SingleConsentRequest getSingleConsentRequest() throws ClassCastException {
        return (SingleConsentRequest)super.getActualInstance();
    }



  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    if (getActualInstance() instanceof EnduringConsentRequest) {
        if (getActualInstance() != null) {
          joiner.add(((EnduringConsentRequest)getActualInstance()).toUrlQueryString(prefix + "one_of_0" + suffix));
        }
        return joiner.toString();
    }
    if (getActualInstance() instanceof SingleConsentRequest) {
        if (getActualInstance() != null) {
          joiner.add(((SingleConsentRequest)getActualInstance()).toUrlQueryString(prefix + "one_of_1" + suffix));
        }
        return joiner.toString();
    }
    return null;
  }

}

