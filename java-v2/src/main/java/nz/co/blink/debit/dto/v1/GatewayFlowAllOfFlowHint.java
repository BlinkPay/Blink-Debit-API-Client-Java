/*
 * Blink Debit (PayNow and AutoPay) Payments API
 * APIs to execute Direct Credit payments for customers who use online banking with supported banks.  These APIs power **Blink PayNow** enabling one-off payments, and **Blink AutoPay** enabling recurring payments.  **Request IDs** Request IDs are included in the header in every response, to assist in tracing and debugging.  **API Change Policy** Additive changes may be made to request query parameters and JSON responses. To preserve backward compatibility, endpoint naming updates or JSON elements that already exist will not be removed or renamed until a major version (URL) change. This policy applies only after the official v1 release.
 *
 * The version of the OpenAPI document: 1.0.30
 * Contact: sysadmin@blinkpay.co.nz
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package nz.co.blink.debit.dto.v1;

import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import java.util.Locale;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.util.Arrays;
import nz.co.blink.debit.dto.v1.Bank;
import nz.co.blink.debit.dto.v1.DecoupledFlowHint;
import nz.co.blink.debit.dto.v1.IdentifierType;
import nz.co.blink.debit.dto.v1.RedirectFlowHint;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import javax.validation.constraints.*;
import javax.validation.Valid;

import com.fasterxml.jackson.core.type.TypeReference;

import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Locale;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.MapperFeature;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;
import nz.co.blink.debit.dto.JSON;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.17.0")
@JsonDeserialize(using = GatewayFlowAllOfFlowHint.GatewayFlowAllOfFlowHintDeserializer.class)
@JsonSerialize(using = GatewayFlowAllOfFlowHint.GatewayFlowAllOfFlowHintSerializer.class)
public class GatewayFlowAllOfFlowHint extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(GatewayFlowAllOfFlowHint.class.getName());

    public static class GatewayFlowAllOfFlowHintSerializer extends StdSerializer<GatewayFlowAllOfFlowHint> {
        public GatewayFlowAllOfFlowHintSerializer(Class<GatewayFlowAllOfFlowHint> t) {
            super(t);
        }

        public GatewayFlowAllOfFlowHintSerializer() {
            this(null);
        }

        @Override
        public void serialize(GatewayFlowAllOfFlowHint value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {
            jgen.writeObject(value.getActualInstance());
        }
    }

    public static class GatewayFlowAllOfFlowHintDeserializer extends StdDeserializer<GatewayFlowAllOfFlowHint> {
        public GatewayFlowAllOfFlowHintDeserializer() {
            this(GatewayFlowAllOfFlowHint.class);
        }

        public GatewayFlowAllOfFlowHintDeserializer(Class<?> vc) {
            super(vc);
        }

        @Override
        public GatewayFlowAllOfFlowHint deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {
            JsonNode tree = jp.readValueAsTree();
            Object deserialized = null;
            boolean typeCoercion = ctxt.isEnabled(MapperFeature.ALLOW_COERCION_OF_SCALARS);
            int match = 0;
            JsonToken token = tree.traverse(jp.getCodec()).nextToken();
            // deserialize DecoupledFlowHint
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (DecoupledFlowHint.class.equals(Integer.class) || DecoupledFlowHint.class.equals(Long.class) || DecoupledFlowHint.class.equals(Float.class) || DecoupledFlowHint.class.equals(Double.class) || DecoupledFlowHint.class.equals(Boolean.class) || DecoupledFlowHint.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((DecoupledFlowHint.class.equals(Integer.class) || DecoupledFlowHint.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((DecoupledFlowHint.class.equals(Float.class) || DecoupledFlowHint.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (DecoupledFlowHint.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (DecoupledFlowHint.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(DecoupledFlowHint.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'DecoupledFlowHint'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'DecoupledFlowHint'", e);
            }

            // deserialize RedirectFlowHint
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (RedirectFlowHint.class.equals(Integer.class) || RedirectFlowHint.class.equals(Long.class) || RedirectFlowHint.class.equals(Float.class) || RedirectFlowHint.class.equals(Double.class) || RedirectFlowHint.class.equals(Boolean.class) || RedirectFlowHint.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((RedirectFlowHint.class.equals(Integer.class) || RedirectFlowHint.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((RedirectFlowHint.class.equals(Float.class) || RedirectFlowHint.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (RedirectFlowHint.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (RedirectFlowHint.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(RedirectFlowHint.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'RedirectFlowHint'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'RedirectFlowHint'", e);
            }

            if (match == 1) {
                GatewayFlowAllOfFlowHint ret = new GatewayFlowAllOfFlowHint();
                ret.setActualInstance(deserialized);
                return ret;
            }
            throw new IOException(String.format(Locale.ROOT, "Failed deserialization for GatewayFlowAllOfFlowHint: %d classes match result, expected 1", match));
        }

        /**
         * Handle deserialization of the 'null' value.
         */
        @Override
        public GatewayFlowAllOfFlowHint getNullValue(DeserializationContext ctxt) throws JsonMappingException {
            throw new JsonMappingException(ctxt.getParser(), "GatewayFlowAllOfFlowHint cannot be null");
        }
    }

    // store a list of schema names defined in oneOf
    public static final Map<String, Class<?>> schemas = new HashMap<>();

    public GatewayFlowAllOfFlowHint() {
        super("oneOf", Boolean.FALSE);
    }
  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   * @param key the name of the property
   * @param value the value of the property
   * @return self reference
   */
  @JsonAnySetter
  public GatewayFlowAllOfFlowHint putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) properties.
   * @return the additional (undeclared) properties
   */
  @JsonAnyGetter
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   * @param key the name of the property
   * @return the additional (undeclared) property with the specified name
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }

    /**
     * Return true if this gateway_flow_allOf_flow_hint object is equal to o.
     */
    @Override
    public boolean equals(Object o) {
        return super.equals(o) && Objects.equals(this.additionalProperties, ((GatewayFlowAllOfFlowHint)o).additionalProperties);
    }

    @Override
    public int hashCode() {
        return Objects.hash(getActualInstance(), isNullable(), getSchemaType(), additionalProperties);
    }
    public GatewayFlowAllOfFlowHint(DecoupledFlowHint o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public GatewayFlowAllOfFlowHint(RedirectFlowHint o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("DecoupledFlowHint", DecoupledFlowHint.class);
        schemas.put("RedirectFlowHint", RedirectFlowHint.class);
        JSON.registerDescendants(GatewayFlowAllOfFlowHint.class, Collections.unmodifiableMap(schemas));
        // Initialize and register the discriminator mappings.
        Map<String, Class<?>> mappings = new HashMap<String, Class<?>>();
        mappings.put("decoupled", DecoupledFlowHint.class);
        mappings.put("redirect", RedirectFlowHint.class);
        mappings.put("gateway_flow_allOf_flow_hint", GatewayFlowAllOfFlowHint.class);
        JSON.registerDiscriminator(GatewayFlowAllOfFlowHint.class, "type", mappings);
    }

    @Override
    public Map<String, Class<?>> getSchemas() {
        return GatewayFlowAllOfFlowHint.schemas;
    }

    /**
     * Set the instance that matches the oneOf child schema, check
     * the instance parameter is valid against the oneOf child schemas:
     * DecoupledFlowHint, RedirectFlowHint
     *
     * It could be an instance of the 'oneOf' schemas.
     * The oneOf child schemas may themselves be a composed schema (allOf, anyOf, oneOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (JSON.isInstanceOf(DecoupledFlowHint.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(RedirectFlowHint.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be DecoupledFlowHint, RedirectFlowHint");
    }

    /**
     * Get the actual instance, which can be the following:
     * DecoupledFlowHint, RedirectFlowHint
     *
     * @return The actual instance (DecoupledFlowHint, RedirectFlowHint)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of `DecoupledFlowHint`. If the actual instance is not `DecoupledFlowHint`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `DecoupledFlowHint`
     * @throws ClassCastException if the instance is not `DecoupledFlowHint`
     */
    public DecoupledFlowHint getDecoupledFlowHint() throws ClassCastException {
        return (DecoupledFlowHint)super.getActualInstance();
    }

    /**
     * Get the actual instance of `RedirectFlowHint`. If the actual instance is not `RedirectFlowHint`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `RedirectFlowHint`
     * @throws ClassCastException if the instance is not `RedirectFlowHint`
     */
    public RedirectFlowHint getRedirectFlowHint() throws ClassCastException {
        return (RedirectFlowHint)super.getActualInstance();
    }



  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    if (getActualInstance() instanceof RedirectFlowHint) {
        if (getActualInstance() != null) {
          joiner.add(((RedirectFlowHint)getActualInstance()).toUrlQueryString(prefix + "one_of_0" + suffix));
        }
        return joiner.toString();
    }
    if (getActualInstance() instanceof DecoupledFlowHint) {
        if (getActualInstance() != null) {
          joiner.add(((DecoupledFlowHint)getActualInstance()).toUrlQueryString(prefix + "one_of_1" + suffix));
        }
        return joiner.toString();
    }
    return null;
  }

}

