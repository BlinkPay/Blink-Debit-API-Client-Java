/*
 * Blink Debit (PayNow and AutoPay) Payments API
 * APIs to execute Direct Credit payments for customers who use online banking with supported banks.  These APIs power **Blink PayNow** enabling one-off payments, and **Blink AutoPay** enabling recurring payments.  **Request IDs** Request IDs are included in the header in every response, to assist in tracing and debugging.  **API Change Policy** Additive changes may be made to request query parameters and JSON responses. To preserve backward compatibility, endpoint naming updates or JSON elements that already exist will not be removed or renamed until a major version (URL) change. This policy applies only after the official v1 release.
 *
 * The version of the OpenAPI document: 1.0.30
 * Contact: sysadmin@blinkpay.co.nz
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package nz.co.blink.debit.dto.v1;

import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import java.util.Locale;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.net.URI;
import java.util.Arrays;
import nz.co.blink.debit.dto.v1.AuthFlowDetail;
import nz.co.blink.debit.dto.v1.GatewayFlowAllOfFlowHint;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import javax.validation.constraints.*;
import javax.validation.Valid;


import nz.co.blink.debit.dto.JSON;
/**
 * The details for a Gateway flow.
 */
@JsonPropertyOrder({
  GatewayFlow.JSON_PROPERTY_REDIRECT_URI,
  GatewayFlow.JSON_PROPERTY_REDIRECT_TO_APP,
  GatewayFlow.JSON_PROPERTY_FLOW_HINT
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.17.0")
@JsonIgnoreProperties(
  value = "type", // ignore manually set type, it will be automatically generated by Jackson during serialization
  allowSetters = true // allows the type to be set during deserialization
)
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "type", visible = true)

public class GatewayFlow extends AuthFlowDetail {
  public static final String JSON_PROPERTY_REDIRECT_URI = "redirect_uri";
  
  private URI redirectUri;

  public static final String JSON_PROPERTY_REDIRECT_TO_APP = "redirect_to_app";
  
  private Boolean redirectToApp = false;

  public static final String JSON_PROPERTY_FLOW_HINT = "flow_hint";
  
  private GatewayFlowAllOfFlowHint flowHint;

  public GatewayFlow() { 
  }

  public GatewayFlow redirectUri( URI redirectUri) {
    this.redirectUri = redirectUri;
    return this;
  }

  /**
   * The URL to redirect back to once the payment is completed through the gateway. The &#x60;cid&#x60; (Consent ID) will be added as a URL parameter. If there is an error, an &#x60;error&#x60; parameter will be appended also.
   * @return redirectUri
   */
  
  @NotNull
  @Valid

  @JsonProperty(value = JSON_PROPERTY_REDIRECT_URI, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public URI getRedirectUri() {
    return redirectUri;
  }


  @JsonProperty(value = JSON_PROPERTY_REDIRECT_URI, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setRedirectUri( URI redirectUri) {
    this.redirectUri = redirectUri;
  }


  public GatewayFlow redirectToApp( Boolean redirectToApp) {
    this.redirectToApp = redirectToApp;
    return this;
  }

  /**
   * Whether the redirect URI goes back to an app directly. If this value is true, the app will receive code and state parameters with this redirection. The app must pass these through to us at: https://debit.blinkpay.co.nz/bank/1.0/return?state&#x3D;{state}&amp;code&#x3D;{code}&amp;redirect&#x3D;false, along with other query parameters like error.
   * @return redirectToApp
   */
  

  @JsonProperty(value = JSON_PROPERTY_REDIRECT_TO_APP, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Boolean getRedirectToApp() {
    return redirectToApp;
  }


  @JsonProperty(value = JSON_PROPERTY_REDIRECT_TO_APP, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRedirectToApp( Boolean redirectToApp) {
    this.redirectToApp = redirectToApp;
  }


  public GatewayFlow flowHint( GatewayFlowAllOfFlowHint flowHint) {
    this.flowHint = flowHint;
    return this;
  }

  /**
   * Get flowHint
   * @return flowHint
   */
  
  @Valid

  @JsonProperty(value = JSON_PROPERTY_FLOW_HINT, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public GatewayFlowAllOfFlowHint getFlowHint() {
    return flowHint;
  }


  @JsonProperty(value = JSON_PROPERTY_FLOW_HINT, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setFlowHint( GatewayFlowAllOfFlowHint flowHint) {
    this.flowHint = flowHint;
  }

  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   * @param key the name of the property
   * @param value the value of the property
   * @return self reference
   */
  @JsonAnySetter
  public GatewayFlow putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) properties.
   * @return the additional (undeclared) properties
   */
  @JsonAnyGetter
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   * @param key the name of the property
   * @return the additional (undeclared) property with the specified name
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }

  @Override
  public GatewayFlow type( TypeEnum type) {
    this.setType(type);
    return this;
  }

  /**
   * Return true if this gateway-flow object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GatewayFlow gatewayFlow = (GatewayFlow) o;
    return Objects.equals(this.redirectUri, gatewayFlow.redirectUri) &&
        Objects.equals(this.redirectToApp, gatewayFlow.redirectToApp) &&
        Objects.equals(this.flowHint, gatewayFlow.flowHint)&&
        Objects.equals(this.additionalProperties, gatewayFlow.additionalProperties) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(redirectUri, redirectToApp, flowHint, super.hashCode(), additionalProperties);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GatewayFlow {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    redirectUri: ").append(toIndentedString(redirectUri)).append("\n");
    sb.append("    redirectToApp: ").append(toIndentedString(redirectToApp)).append("\n");
    sb.append("    flowHint: ").append(toIndentedString(flowHint)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    // add `type` to the URL query string
    if (getType() != null) {
      joiner.add(String.format(Locale.ROOT, "%stype%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getType()))));
    }

    // add `redirect_uri` to the URL query string
    if (getRedirectUri() != null) {
      joiner.add(String.format(Locale.ROOT, "%sredirect_uri%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getRedirectUri()))));
    }

    // add `redirect_to_app` to the URL query string
    if (getRedirectToApp() != null) {
      joiner.add(String.format(Locale.ROOT, "%sredirect_to_app%s=%s", prefix, suffix, ApiClient.urlEncode(ApiClient.valueToString(getRedirectToApp()))));
    }

    // add `flow_hint` to the URL query string
    if (getFlowHint() != null) {
      joiner.add(getFlowHint().toUrlQueryString(prefix + "flow_hint" + suffix));
    }

    return joiner.toString();
  }
static {
  // Initialize and register the discriminator mappings.
  Map<String, Class<?>> mappings = new HashMap<String, Class<?>>();
  mappings.put("gateway-flow", GatewayFlow.class);
  JSON.registerDiscriminator(GatewayFlow.class, "type", mappings);
}
}

