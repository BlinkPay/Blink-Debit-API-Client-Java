/*
 * Blink Debit (PayNow and AutoPay) Payments API
 * APIs to execute Direct Credit payments for customers who use online banking with supported banks.  These APIs power **Blink PayNow** enabling one-off payments, and **Blink AutoPay** enabling recurring payments.  **Request IDs** Request IDs are included in the header in every response, to assist in tracing and debugging.  **API Change Policy** Additive changes may be made to request query parameters and JSON responses. To preserve backward compatibility, endpoint naming updates or JSON elements that already exist will not be removed or renamed until a major version (URL) change. This policy applies only after the official v1 release.
 *
 * The version of the OpenAPI document: 1.0.30
 * Contact: sysadmin@blinkpay.co.nz
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package nz.co.blink.debit.dto.v1;

import nz.co.blink.debit.dto.AbstractOpenApiSchema;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import java.util.Locale;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.net.URI;
import java.util.Arrays;
import java.util.UUID;
import nz.co.blink.debit.dto.v1.AccountNumberRefundRequest;
import nz.co.blink.debit.dto.v1.Amount;
import nz.co.blink.debit.dto.v1.FullRefundRequest;
import nz.co.blink.debit.dto.v1.PartialRefundRequest;
import nz.co.blink.debit.dto.v1.Pcr;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import javax.validation.constraints.*;
import javax.validation.Valid;

import com.fasterxml.jackson.core.type.TypeReference;

import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Locale;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.MapperFeature;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;
import nz.co.blink.debit.dto.JSON;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.17.0")
@JsonDeserialize(using = RefundRequest.RefundRequestDeserializer.class)
@JsonSerialize(using = RefundRequest.RefundRequestSerializer.class)
public class RefundRequest extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(RefundRequest.class.getName());

    public enum TypeEnum {
        ACCOUNT_NUMBER("account_number"), PARTIAL_REFUND("partial_refund"), FULL_REFUND("full_refund");
        private String value;
        TypeEnum(String value) { this.value = value; }
        @Override
        @JsonValue
        public String toString() { return String.valueOf(value); }
        @JsonCreator
        public static TypeEnum fromValue(String type) {
            for (TypeEnum t : TypeEnum.values()) if (String.valueOf(t.value).equals(type)) return t;
            throw new IllegalArgumentException("Unknown type: " + type);
        }
    }
    private TypeEnum type;
    public RefundRequest type(TypeEnum type) { this.type = type; return this; }
    public TypeEnum getType() { return type; }
    public void setType(TypeEnum type) { this.type = type; }

    public static class RefundRequestSerializer extends StdSerializer<RefundRequest> {
        public RefundRequestSerializer(Class<RefundRequest> t) {
            super(t);
        }

        public RefundRequestSerializer() {
            this(null);
        }

        @Override
        public void serialize(RefundRequest value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {
            jgen.writeObject(value.getActualInstance());
        }
    }

    public static class RefundRequestDeserializer extends StdDeserializer<RefundRequest> {
        public RefundRequestDeserializer() {
            this(RefundRequest.class);
        }

        public RefundRequestDeserializer(Class<?> vc) {
            super(vc);
        }

        @Override
        public RefundRequest deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {
            JsonNode tree = jp.readValueAsTree();
            Object deserialized = null;
            boolean typeCoercion = ctxt.isEnabled(MapperFeature.ALLOW_COERCION_OF_SCALARS);
            int match = 0;
            JsonToken token = tree.traverse(jp.getCodec()).nextToken();
            // deserialize AccountNumberRefundRequest
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (AccountNumberRefundRequest.class.equals(Integer.class) || AccountNumberRefundRequest.class.equals(Long.class) || AccountNumberRefundRequest.class.equals(Float.class) || AccountNumberRefundRequest.class.equals(Double.class) || AccountNumberRefundRequest.class.equals(Boolean.class) || AccountNumberRefundRequest.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((AccountNumberRefundRequest.class.equals(Integer.class) || AccountNumberRefundRequest.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((AccountNumberRefundRequest.class.equals(Float.class) || AccountNumberRefundRequest.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (AccountNumberRefundRequest.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (AccountNumberRefundRequest.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(AccountNumberRefundRequest.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'AccountNumberRefundRequest'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'AccountNumberRefundRequest'", e);
            }

            // deserialize FullRefundRequest
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (FullRefundRequest.class.equals(Integer.class) || FullRefundRequest.class.equals(Long.class) || FullRefundRequest.class.equals(Float.class) || FullRefundRequest.class.equals(Double.class) || FullRefundRequest.class.equals(Boolean.class) || FullRefundRequest.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((FullRefundRequest.class.equals(Integer.class) || FullRefundRequest.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((FullRefundRequest.class.equals(Float.class) || FullRefundRequest.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (FullRefundRequest.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (FullRefundRequest.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(FullRefundRequest.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'FullRefundRequest'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'FullRefundRequest'", e);
            }

            // deserialize PartialRefundRequest
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (PartialRefundRequest.class.equals(Integer.class) || PartialRefundRequest.class.equals(Long.class) || PartialRefundRequest.class.equals(Float.class) || PartialRefundRequest.class.equals(Double.class) || PartialRefundRequest.class.equals(Boolean.class) || PartialRefundRequest.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((PartialRefundRequest.class.equals(Integer.class) || PartialRefundRequest.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((PartialRefundRequest.class.equals(Float.class) || PartialRefundRequest.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (PartialRefundRequest.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (PartialRefundRequest.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(PartialRefundRequest.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'PartialRefundRequest'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'PartialRefundRequest'", e);
            }

            if (match == 1) {
                RefundRequest ret = new RefundRequest();
                ret.setActualInstance(deserialized);
                return ret;
            }
            throw new IOException(String.format(Locale.ROOT, "Failed deserialization for RefundRequest: %d classes match result, expected 1", match));
        }

        /**
         * Handle deserialization of the 'null' value.
         */
        @Override
        public RefundRequest getNullValue(DeserializationContext ctxt) throws JsonMappingException {
            throw new JsonMappingException(ctxt.getParser(), "RefundRequest cannot be null");
        }
    }

    // store a list of schema names defined in oneOf
    public static final Map<String, Class<?>> schemas = new HashMap<>();

    public RefundRequest() {
        super("oneOf", Boolean.FALSE);
    }
  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   * @param key the name of the property
   * @param value the value of the property
   * @return self reference
   */
  @JsonAnySetter
  public RefundRequest putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) properties.
   * @return the additional (undeclared) properties
   */
  @JsonAnyGetter
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   * @param key the name of the property
   * @return the additional (undeclared) property with the specified name
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }

    /**
     * Return true if this refund-request object is equal to o.
     */
    @Override
    public boolean equals(Object o) {
        return super.equals(o) && Objects.equals(this.additionalProperties, ((RefundRequest)o).additionalProperties);
    }

    @Override
    public int hashCode() {
        return Objects.hash(getActualInstance(), isNullable(), getSchemaType(), additionalProperties);
    }
    public RefundRequest(AccountNumberRefundRequest o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public RefundRequest(FullRefundRequest o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public RefundRequest(PartialRefundRequest o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("AccountNumberRefundRequest", AccountNumberRefundRequest.class);
        schemas.put("FullRefundRequest", FullRefundRequest.class);
        schemas.put("PartialRefundRequest", PartialRefundRequest.class);
        JSON.registerDescendants(RefundRequest.class, Collections.unmodifiableMap(schemas));
        // Initialize and register the discriminator mappings.
        Map<String, Class<?>> mappings = new HashMap<String, Class<?>>();
        mappings.put("account_number", AccountNumberRefundRequest.class);
        mappings.put("full_refund", FullRefundRequest.class);
        mappings.put("partial_refund", PartialRefundRequest.class);
        mappings.put("refund-request", RefundRequest.class);
        JSON.registerDiscriminator(RefundRequest.class, "type", mappings);
    }

    @Override
    public Map<String, Class<?>> getSchemas() {
        return RefundRequest.schemas;
    }

    /**
     * Set the instance that matches the oneOf child schema, check
     * the instance parameter is valid against the oneOf child schemas:
     * AccountNumberRefundRequest, FullRefundRequest, PartialRefundRequest
     *
     * It could be an instance of the 'oneOf' schemas.
     * The oneOf child schemas may themselves be a composed schema (allOf, anyOf, oneOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (JSON.isInstanceOf(AccountNumberRefundRequest.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(FullRefundRequest.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(PartialRefundRequest.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be AccountNumberRefundRequest, FullRefundRequest, PartialRefundRequest");
    }

    /**
     * Get the actual instance, which can be the following:
     * AccountNumberRefundRequest, FullRefundRequest, PartialRefundRequest
     *
     * @return The actual instance (AccountNumberRefundRequest, FullRefundRequest, PartialRefundRequest)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of `AccountNumberRefundRequest`. If the actual instance is not `AccountNumberRefundRequest`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `AccountNumberRefundRequest`
     * @throws ClassCastException if the instance is not `AccountNumberRefundRequest`
     */
    public AccountNumberRefundRequest getAccountNumberRefundRequest() throws ClassCastException {
        return (AccountNumberRefundRequest)super.getActualInstance();
    }

    /**
     * Get the actual instance of `FullRefundRequest`. If the actual instance is not `FullRefundRequest`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `FullRefundRequest`
     * @throws ClassCastException if the instance is not `FullRefundRequest`
     */
    public FullRefundRequest getFullRefundRequest() throws ClassCastException {
        return (FullRefundRequest)super.getActualInstance();
    }

    /**
     * Get the actual instance of `PartialRefundRequest`. If the actual instance is not `PartialRefundRequest`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `PartialRefundRequest`
     * @throws ClassCastException if the instance is not `PartialRefundRequest`
     */
    public PartialRefundRequest getPartialRefundRequest() throws ClassCastException {
        return (PartialRefundRequest)super.getActualInstance();
    }



  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    if (getActualInstance() instanceof AccountNumberRefundRequest) {
        if (getActualInstance() != null) {
          joiner.add(((AccountNumberRefundRequest)getActualInstance()).toUrlQueryString(prefix + "one_of_0" + suffix));
        }
        return joiner.toString();
    }
    if (getActualInstance() instanceof PartialRefundRequest) {
        if (getActualInstance() != null) {
          joiner.add(((PartialRefundRequest)getActualInstance()).toUrlQueryString(prefix + "one_of_1" + suffix));
        }
        return joiner.toString();
    }
    if (getActualInstance() instanceof FullRefundRequest) {
        if (getActualInstance() != null) {
          joiner.add(((FullRefundRequest)getActualInstance()).toUrlQueryString(prefix + "one_of_2" + suffix));
        }
        return joiner.toString();
    }
    return null;
  }

}

